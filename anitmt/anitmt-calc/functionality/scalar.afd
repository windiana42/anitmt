///////////////////////////////////////////////////////////////////////////////
/*****************************************************************************/
/*                                                                           */
/*                                scalar functions                           */
/*                                                                           */
/* subfunctions for scalar animations                                        */
/*                                                                           */
/* - scalar_subfunction (abstract base type)                                 */
/* - change (container type for scalars)                                     */
/* - constant                                                                */
/* - linear                                                                  */
/* - accelerated                                                             */
/*                                                                           */
/*****************************************************************************/
///////////////////////////////////////////////////////////////////////////////


// ****************************************************************************
// ****************************************************************************
// ** dependence
// ****************************************************************************
// ****************************************************************************


include declaration "base_func.afd";
include declaration "scalar_base.afd";


// ****************************************************************************
// ****************************************************************************
// ** node definitions
// ****************************************************************************
// ****************************************************************************

// +--------------------+
// | scalar_subfunction |
// +--------------------+

// abstract type for scalar subfunctions 
abstract node scalar_subfunction extends scalar_base provides scalar_vsa {
  
  common {
    actions {
      // MM: the action levels have to be checked !!!
      
      // times, forward and backward
      push( push_time_fw, end_time, scalar_vsa.next.start_time );
      push( push_time_bw, start_time, scalar_vsa.prev.end_time );
      // values, forward and backward
      push( push_state_fw, end_value, scalar_vsa.next.start_value );
      push( push_state_bw, start_value, scalar_vsa.prev.end_value );
      // slopes, forward and backward
      push( push_speed_fw, end_slope, scalar_vsa.next.start_slope );
      push( push_speed_bw, start_slope, scalar_vsa.prev.end_slope );
    }
  }

}

// +--------+
// | change |
// +--------+

// changing values (container for scalar functions)
node change extends scalar_subfunction {
  
  // scalar subfunction provider type 
  contains {
    min1 scalar_vsa ;
  }
  
  common {
    solvers {
      // setting result function parameters
      equal_solver( start_time, scalar_vsa.value(time).start_param );
      equal_solver( end_time  , scalar_vsa.value(time).end_param   );
      equal_solver( start_time, scalar_vsa.slope(time).start_param );
      equal_solver( end_time  , scalar_vsa.slope(time).end_param   );
      equal_solver( start_time, scalar_vsa.acceleration(time).start_param );
      equal_solver( end_time  , scalar_vsa.acceleration(time).end_param   );

      // connection to subfunctions
      equal_solver ( start_time , first_child.start_time  );
      equal_solver ( start_value, first_child.start_value );
      equal_solver ( start_slope, first_child.start_slope );
      equal_solver ( end_time , last_child.end_time  );      
      equal_solver ( end_value, last_child.end_value );      
      equal_solver ( end_slope, last_child.end_slope );      
    }
  }

  // result functions using the scalar subfunctions
  provide scalar_vsa {
    resulting value( time t ) requires child.scalar_vsa.value ( time ) { 
      [[ return child.scalar_vsa.value ( time t ) ]];
    } 
    resulting slope( time t ) requires child.scalar_vsa.slope ( time ) {
      [[ return child.scalar_vsa.slope ( time t ) ]];
    }
    resulting acceleration( time t ) requires child.scalar_vsa.acceleration ( time ) {
      [[ return child.scalar_vsa.acceleration ( time t ) ]];
    }
  }
}

// +----------+
// | constant |
// +----------+

// constant value
node constant extends scalar_subfunction {
  
  // special properties for constant
  properties{
    type scalar {    
      value;
      slope;
      acceleration;
    }
  }
  
  common {
    solvers {
      // setting result function parameters
      equal_solver( start_time, scalar_vsa.value(time).start_param );
      equal_solver( end_time  , scalar_vsa.value(time).end_param   );
      equal_solver( start_time, scalar_vsa.slope(time).start_param );
      equal_solver( end_time  , scalar_vsa.slope(time).end_param   );
      equal_solver( start_time, scalar_vsa.acceleration(time).start_param );
      equal_solver( end_time  , scalar_vsa.acceleration(time).end_param   );

      // solvers for constant
      difference = 0; 
      slope_difference = 0; slope = 0;
      acceleration = 0;
      equal_solver( value, start_value );
      equal_solver( value, end_value );
    }
    
    actions {
      default( default_duration, duration, 0 );
      default( default_state, start_value, 0 );
    }
  }

  // result functions for constant
  provide scalar_vsa {
    resulting value( time t ) requires value
    {
      [[ return_prop value ]];
    }
    resulting slope( time t ) 
    {
      [[ return 0 ]];
    }
    resulting acceleration( time t ) 
    {
      [[ return 0 ]];
    }
  }
}

// +--------+
// | linear |
// +--------+

// linear change of a value
node linear extends scalar_subfunction provides scalar_vsa {

  // special properties for linear
  properties{
    type scalar {    
      slope;
      acceleration;
    }
  }

  common {
    solvers {
      // setting result function parameters
      equal_solver( start_time, scalar_vsa.value(time).start_param );
      equal_solver( end_time  , scalar_vsa.value(time).end_param   );
      equal_solver( start_time, scalar_vsa.slope(time).start_param );
      equal_solver( end_time  , scalar_vsa.slope(time).end_param   );
      equal_solver( start_time, scalar_vsa.acceleration(time).start_param );
      equal_solver( end_time  , scalar_vsa.acceleration(time).end_param   );

      acceleration = 0;
      product_solver( difference, slope, duration );
      equal_solver( slope, start_slope );
      equal_solver( slope, end_slope   );
    }
    actions {
      // MM: the action levels have to be checked

      default( default_speed, slope, 0 );
      default( default_duration, duration, 0 );
      default( default_state, start_value, 0 );
    }
  }

  // result functions for linear
  provide scalar_vsa {
    resulting value( time t ) requires start_value, start_time, slope
    {
      scalar res = [[ start_value ]] + (t - [[ start_time ]]) * [[ slope ]];
      [[ return res ]];
    }
    resulting slope( time t ) requires slope
    {
      [[ return_prop slope ]];
    }
    resulting acceleration( time t ) 
    {
      [[ return 0 ]];
    }
  }
}


// +-------------+
// | accelerated |
// +-------------+

// accelerated change of values
node accelerated extends scalar_subfunction provides scalar_vsa {

  // special properties for accelerated
  properties{
    scalar acceleration;
  }

  common {
    solvers {
      // setting result function parameters
      equal_solver( start_time, scalar_vsa.value(time).start_param );
      equal_solver( end_time  , scalar_vsa.value(time).end_param   );
      equal_solver( start_time, scalar_vsa.slope(time).start_param );
      equal_solver( end_time  , scalar_vsa.slope(time).end_param   );
      equal_solver( start_time, scalar_vsa.acceleration(time).start_param );
      equal_solver( end_time  , scalar_vsa.acceleration(time).end_param   );

      // acceleration solvers
      // still wrong (simple solver):
      accel_solver(difference, duration, acceleration, start_slope, end_slope);
      // correct (better solver): 
      // accel_solver(difference, duration, acceleration, start_slope, end_slope, slope_difference);
    }
    actions {
      // MM: the action levels have to be checked !!! 
      
      default( default_acceleration,  acceleration, 0 ); // <-- still wrong better is:
      // default(200,  slope_difference, 0 );
      default( default_speed, start_slope, 0 );
      default( default_duration, duration, 0 );
      default( default_state, start_value, 0 );
    }
  }

  // result functions for accelerated
  provide scalar_vsa {
    resulting value(time abs_t) 
    requires start_value, start_time, start_slope, acceleration
    {
      scalar t = abs_t - [[ start_time ]];
      scalar res = [[ start_value ]] + [[ start_slope ]]*t + 0.5*[[ acceleration ]]*t*t;
      [[ return res ]];
    }
    resulting slope( time abs_t ) 
    requires start_time, start_slope, acceleration
    {
      scalar t = abs_t - [[ start_time ]];
      scalar res = [[ start_slope ]] + [[ acceleration ]] * t;
      [[ return res ]];
    }
    resulting acceleration( time t ) 
    requires acceleration
    {
      [[ return_prop acceleration ]];
    }
  }
}

// +----+
// | if |
// +----+

// switching between scalar functions (container for then and else)
node if extends scalar_subfunction provides scalar_vsa {
  
  properties {
    // MM: boolean property not finished yet
    type flag {    
      condition;
    }
  }
  
  // scalar subfunction provider type 
  contains {
    max1 min1 scalar_then_vsa;
    max1 min1 scalar_else_vsa;
  }
  
  common {
    solvers {
      // setting result function parameters
      equal_solver( start_time, scalar_vsa.value(time).start_param );
      equal_solver( end_time  , scalar_vsa.value(time).end_param   );
      equal_solver( start_time, scalar_vsa.slope(time).start_param );
      equal_solver( end_time  , scalar_vsa.slope(time).end_param   );
      equal_solver( start_time, scalar_vsa.acceleration(time).start_param );
      equal_solver( end_time  , scalar_vsa.acceleration(time).end_param   );
    }

    // special actions connecting only when condition is determined 
    // on a low level with high priority 
    // MM: Have to be implemented 
    actions {
      condition_push (  cond_push_start_time_from_child	, child.scalar_then_vsa.first.start_time        , start_time                                    ,   condition  );
      condition_push (  cond_push_start_time_from_child	, child.scalar_else_vsa.first.start_time        , start_time                                    , ! condition  );
      condition_push (  cond_push_start_time_to_child	, start_time                                    , child.scalar_then_vsa.first.start_time        ,   condition  );
      condition_push (  cond_push_start_time_to_child	, start_time                                    , child.scalar_else_vsa.first.start_time        , ! condition  );
      condition_push (  cond_push_end_time_from_child	, child.scalar_then_vsa.last.end_time           , end_time                                      ,   condition  );
      condition_push (  cond_push_end_time_from_child	, child.scalar_else_vsa.last.end_time           , end_time                                      , ! condition  );
      condition_push (  cond_push_end_time_to_child	, end_time                                      , child.scalar_then_vsa.last.end_time           ,   condition  );
      condition_push (  cond_push_end_time_to_child	, end_time                                      , child.scalar_else_vsa.last.end_time           , ! condition  );
      condition_push (  cond_push_start_value_from_child, child.scalar_then_vsa.first.start_value       , start_value                                   ,   condition  );
      condition_push (  cond_push_start_value_from_child, child.scalar_else_vsa.first.start_value       , start_value                                   , ! condition  );
      condition_push (  cond_push_start_value_to_child	, start_value                                   , child.scalar_then_vsa.first.start_value       ,   condition  );
      condition_push (  cond_push_start_value_to_child	, start_value                                   , child.scalar_else_vsa.first.start_value       , ! condition  );
      condition_push (  cond_push_end_value_from_child	, child.scalar_then_vsa.last.end_value          , end_value                                     ,   condition  );
      condition_push (  cond_push_end_value_from_child	, child.scalar_else_vsa.last.end_value          , end_value                                     , ! condition  );
      condition_push (  cond_push_end_value_to_child	, end_value                                     , child.scalar_then_vsa.last.end_value          ,   condition  );
      condition_push (  cond_push_end_value_to_child	, end_value                                     , child.scalar_else_vsa.last.end_value          , ! condition  );
      condition_push (  cond_push_start_slope_from_child, child.scalar_then_vsa.first.start_slope       , start_slope                                   ,   condition  );
      condition_push (  cond_push_start_slope_from_child, child.scalar_else_vsa.first.start_slope       , start_slope                                   , ! condition  );
      condition_push (  cond_push_start_slope_to_child	, start_slope                                   , child.scalar_then_vsa.first.start_slope       ,   condition  );
      condition_push (  cond_push_start_slope_to_child	, start_slope                                   , child.scalar_else_vsa.first.start_slope       , ! condition  );
      condition_push (  cond_push_end_slope_from_child	, child.scalar_then_vsa.last.end_slope          , end_slope                                     ,   condition  );
      condition_push (  cond_push_end_slope_from_child	, child.scalar_else_vsa.last.end_slope          , end_slope                                     , ! condition  );
      condition_push (  cond_push_end_slope_to_child	, end_slope                                     , child.scalar_then_vsa.last.end_slope          ,   condition  );
      condition_push (  cond_push_end_slope_to_child	, end_slope                                     , child.scalar_else_vsa.last.end_slope          , ! condition  );
/*
      condition_push (  cond_push_start_acceleration_to_child	, child.scalar_then_vsa.first.start_acceleration, start_acceleration                            ,   condition  );
      condition_push (  9, child.scalar_else_vsa.first.start_acceleration, start_acceleration                            , ! condition  );
      condition_push ( 10, start_acceleration                            , child.scalar_then_vsa.first.start_acceleration,   condition  );
      condition_push ( 10, start_acceleration                            , child.scalar_else_vsa.first.start_acceleration, ! condition  );
      condition_push ( 11, child.scalar_then_vsa.last.end_acceleration   , end_acceleration                              ,   condition  );
      condition_push ( 11, child.scalar_else_vsa.last.end_acceleration   , end_acceleration                              , ! condition  );
      condition_push ( 12, end_acceleration                              , child.scalar_then_vsa.last.end_acceleration   ,   condition  );
      condition_push ( 12, end_acceleration                              , child.scalar_else_vsa.last.end_acceleration   , ! condition  );
*/
    }
  }


  // result functions using the scalar subfunctions
  // MM: Using the boolean type, may not work in the moment
  provide scalar_vsa {
    resulting value ( time t ) 
    requires child.scalar_then_vsa.value ( time ), child.scalar_else_vsa.value ( time ) { 
      scalar res = [[condition]] ? [[ child.scalar_then_vsa.value ( time t ) ]] : [[ child.scalar_else_vsa.value ( time t ) ]];
      [[ return res]];
    } 
    resulting slope ( time t ) 
    requires child.scalar_then_vsa.slope ( time ), child.scalar_else_vsa.slope ( time ) { 
      scalar res = [[ condition ]] ? [[child.scalar_then_vsa.slope ( time t ) ]] : [[child.scalar_else_vsa.slope ( time t ) ]];
      [[ return res]];
    } 
    resulting acceleration ( time t ) 
    requires child.scalar_then_vsa.acceleration ( time ), child.scalar_else_vsa.acceleration ( time ) { 
      scalar res = [[ condition ]] ? [[child.scalar_then_vsa.acceleration ( time t ) ]] : [[child.scalar_else_vsa.acceleration ( time t ) ]];
      [[ return res]];
    } 
  }
}

// +------+
// | then |
// +------+

// then container for if function (container for scalar functions)
node then extends scalar_base provides scalar_then_vsa {
  
  // scalar subfunction provider type 
  contains {
    min1 scalar_vsa;
  }
  
  common {
    solvers {
      // setting result function parameters
      equal_solver( start_time, scalar_then_vsa.value(time).start_param );
      equal_solver( end_time  , scalar_then_vsa.value(time).end_param   );
      equal_solver( start_time, scalar_then_vsa.slope(time).start_param );
      equal_solver( end_time  , scalar_then_vsa.slope(time).end_param   );
      equal_solver( start_time, scalar_then_vsa.acceleration(time).start_param );
      equal_solver( end_time  , scalar_then_vsa.acceleration(time).end_param   );

      // connection to subfunctions (then)
      equal_solver ( start_time , child.scalar_vsa.first.start_time  );
      equal_solver ( start_value, child.scalar_vsa.first.start_value );
      equal_solver ( start_slope, child.scalar_vsa.first.start_slope );
      equal_solver ( end_time   , child.scalar_vsa.last.end_time     );      
      equal_solver ( end_value  , child.scalar_vsa.last.end_value    );      
      equal_solver ( end_slope  , child.scalar_vsa.last.end_slope    );      
    }
  }

  // result functions using the scalar subfunctions
  provide scalar_then_vsa {
    resulting value ( time t ) requires child.scalar_vsa.value ( time ) { 
      [[ return child.scalar_vsa.value ( time t )]];
    } 
    resulting slope ( time t ) requires child.scalar_vsa.slope ( time ) { 
      [[ return child.scalar_vsa.slope ( time t )]];
    } 
    resulting acceleration ( time t ) requires child.scalar_vsa.acceleration ( time ) { 
      [[ return child.scalar_vsa.acceleration ( time t )]];
    } 
  }
}

// +------+
// | else |
// +------+

// else container for if function (container for scalar functions)
node else extends scalar_base provides scalar_else_vsa{
  
  // scalar subfunction provider type 
  contains {
    min1 scalar_vsa;
  }
  
  common {
    solvers {
      // setting result function parameters
      equal_solver( start_time, scalar_else_vsa.value(time).start_param );
      equal_solver( end_time  , scalar_else_vsa.value(time).end_param   );
      equal_solver( start_time, scalar_else_vsa.slope(time).start_param );
      equal_solver( end_time  , scalar_else_vsa.slope(time).end_param   );
      equal_solver( start_time, scalar_else_vsa.acceleration(time).start_param );
      equal_solver( end_time  , scalar_else_vsa.acceleration(time).end_param   );

      // connection to subfunctions (then)
      equal_solver ( start_time , child.scalar_vsa.first.start_time  );
      equal_solver ( start_value, child.scalar_vsa.first.start_value );
      equal_solver ( start_slope, child.scalar_vsa.first.start_slope );
      equal_solver ( end_time   , child.scalar_vsa.last.end_time     );      
      equal_solver ( end_value  , child.scalar_vsa.last.end_value    );      
      equal_solver ( end_slope  , child.scalar_vsa.last.end_slope    );      
    }
  }

  // result functions using the scalar subfunctions
  provide scalar_else_vsa {
    resulting value ( time t ) requires child.scalar_vsa.value ( time ) { 
      [[ return child.scalar_vsa.value ( time t )]];
    } 
    resulting slope ( time t ) requires child.scalar_vsa.slope ( time ) { 
      [[ return child.scalar_vsa.slope ( time t )]];
    } 
    resulting acceleration ( time t ) requires child.scalar_vsa.acceleration ( time ) { 
      [[ return child.scalar_vsa.acceleration ( time t )]];
    } 
  }
}

