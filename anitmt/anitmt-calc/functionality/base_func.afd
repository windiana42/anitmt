// ****************************************************************************
// ****************************************************************************
// ** type definitions
// ****************************************************************************
// ****************************************************************************

base_types{
  flag   = values::Flag;
  vector = values::Vector;
  scalar = values::Scalar;
  string = values::String;

  time = scalar;
  value = scalar;
  slope = scalar;
  speed = scalar;
  acceleration = scalar;
  stretch = scalar;
  position = vector;
  direction = vector;
  front = vector;
  up_vector = vector;
  translation = vector;
  rotation = vector;
  
  //orientation = { direction dir, up_vector up };
}

type scene_type {
}

// ******************
// scalar anitmtion
// ******************

type scalar_component {
  provides value (time);
}

serial type scalar_vsa {
  provides value (time);
  provides slope (time);
  provides acceleration (time);
}

// ************************
// vector / point anitmtion
// ************************

type vector_component {
// point
  provides position( time );
  provides direction( time );
  provides speed( time );
// vector
  provides vector( time ); // same as pos( time );
}

serial type vector_state {
// point
  provides position( time );
  provides position( stretch );
  provides direction( time );
  provides direction( stretch );
// timing 
  provides stretch( time );
  provides speed( time );
  provides speed( stretch );
  provides acceleration( time );
  provides acceleration( stretch );
// vector
  provides vector( time );
  provides vector( stretch );
}

// ******************
// object anitmtion
// ******************

type object_component {
  provides translation( time );
  provides rotation( time );
// just in case some additional information
  provides position( time );
  provides front( time );
  provides up_vector( time );
  provides speed( time );
}

serial type object_state {
// track
  provides position( time );
  provides position( stretch );
  provides direction( time );
  provides direction( stretch );
// timing 
  provides stretch( time );
  provides speed( time );
  provides speed( stretch );
  provides acceleration( time );
  provides acceleration( stretch );
// orientation on track
  provides front( time );
  provides front( stretch );
  provides up_vector( time );
  provides up_vector( stretch );
}

serial type track {
  provides position( stretch );
  provides direction( stretch );
}

serial type timing {
  provides stretch( time );
  provides speed( time );
  provides speed( stretch );
  provides acceleration( time );
  provides acceleration( stretch );
}

// ****************
// string anitmtion
// ****************

type string_component {
  provides string( time );
}

serial type string_state {
  provides string( time );
}

// ****************************************************************************
// ****************************************************************************
// ** node definitions
// ****************************************************************************
// ****************************************************************************


// +------+
// | root |
// +------+

node root {
  contains {
    scene_type;
  }
}

// +-------+
// | scene |
// +-------+

node scene provides scene_type {
  properties {
    string filename;
    string scene_type;
  }
  contains {
    scalar_component;
    vector_component;
    object_component;
    string_component; 
  }
}

// ******************
// scalar anitmtion
// ******************

// +-------------+
// | scalar_base |
// +-------------+
// Werte
abstract node scalar_base {
  properties {
    type scalar {    
      start_time;  end_time;  duration;
      start_value; end_value; difference;
      start_slope; end_slope; slope_difference;
    }
  }  
  aliases {
    diff_slope = slope_difference;
    diff_value = difference;
  }
  common {
    constraints {
      duration >= 0;
    }
    solvers {
      sum_solver ( end_time, duration, start_time );
      sum_solver ( end_value, difference, start_value );
      sum_solver ( end_slope, slope_difference, start_slope );
    }
  }
}

// +--------+
// | scalar |
// +--------+
// Werte
                          
// Gültige Subfunktionen:
//   change

node scalar extends scalar_base provides scalar_component, scalar_vsa {
//  ...
  contains {
    min1 scalar_vsa;
  }

  first scalar_vsa {
    actions {
      default(100, start_time, 0 );
      default(1000, start_value, 0 );
    }
  }
  
  provide scalar_vsa {
    resulting value( time t ) 
      requires child.scalar_vsa.value (time) 
    { 
      [return_res child.scalar_vsa.value (time t)];
    } 
    resulting slope( time t ) requires child.scalar_vsa.slope (time) {
      [return_res child.scalar_vsa.slope (time t)];
    }
    resulting acceleration( time t ) requires child.scalar_vsa.acceleration (time) {
      [return_res child.scalar_vsa.acceleration (time t)];
    }
  }
  provide scalar_component {
    resulting value( time t ) 
      requires child.scalar_vsa.value (time) 
    { 
      [return_res child.scalar_vsa.value (time t)];
    } 
  }
}
  
// ******************
// object anitmtion
// ******************

node object provides object_component, object_state
{
  properties
  {
    vector center;
    vector front;
    vector up_vector;
  }
  contains
  {
    min1 object_state;
  }  
  common
  {
//!!! connect start/end params !!!

    actions
    {
      default( 3000, center,    vector(0,0,0) );
      default( 3001, front,     vector(1,0,0) );
      default( 3002, up_vector, vector(0,1,0) );
    }
  }
  provide object_component
  {
    resulting translation( time t ) 
      requires center, child.object_state.position( time )
    {
      vector position = [child.object_state.position( time t )].second;
      vector translate = position - [center];
      [return translate];
    }
    resulting rotation( time t ) 
      requires front, child.object_state.front( time ),
	       up_vector, child.object_state.up_vector( time )
    {
      vector dest_front = [child.object_state.front( time t )].second;
      vector dest_up_vector = [child.object_state.up_vector( time t )].second;
      vector rotate = Vrotate_pair_pair( [front], [up_vector], 
					 dest_front, dest_up_vector );
      [return rotate];
    }

    resulting position( time t ) 
      requires child.object_state.position( time )
    {
      [return_res child.object_state.position( time t )];
    }
    resulting front( time t ) 
      requires child.object_state.front( time )
    {
      [return_res child.object_state.front( time t )];
    }
    resulting up_vector( time t ) 
      requires child.object_state.up_vector( time )
    {
      [return_res child.object_state.up_vector( time t )];
    }
    resulting speed( time t ) 
      requires child.object_state.speed( time )
    {
      [return_res child.object_state.speed( time t )];
    }
  }

  provide object_state
  {
// track
    resulting position( time t ) 
      requires child.object_state.position( time )
    {
      [return_res child.object_state.position( time t )];
    }
    resulting position( stretch s ) 
      requires child.object_state.position( stretch )
    {
      [return_res child.object_state.position( stretch s )];
    }
    resulting direction( time t ) 
      requires child.object_state.direction( time )
    {
      [return_res child.object_state.direction( time t )];
    }
    resulting direction( stretch s ) 
      requires child.object_state.direction( stretch )
    {
      [return_res child.object_state.direction( stretch s )];
    }
// timing 
    resulting stretch( time t ) 
      requires child.object_state.stretch( time )
    {
      [return_res child.object_state.stretch( time t )];
    }
    resulting speed( time t ) 
      requires child.object_state.speed( time )
    {
      [return_res child.object_state.speed( time t )];
    }
    resulting speed( stretch s ) 
      requires child.object_state.speed( stretch )
    {
      [return_res child.object_state.speed( stretch s )];
    }
    resulting acceleration( time t ) 
      requires child.object_state.acceleration( time )
    {
      [return_res child.object_state.acceleration( time t )];
    }
    resulting acceleration( stretch s ) 
      requires child.object_state.acceleration( stretch )
    {
      [return_res child.object_state.acceleration( stretch s )];
    }
// orientation on track
    resulting front( time t ) 
      requires child.object_state.front( time )
    {
      [return_res child.object_state.front( time t )];
    }
    resulting front( stretch s ) 
      requires child.object_state.front( stretch )
    {
      [return_res child.object_state.front( stretch s )];
    }
    resulting up_vector( time t ) 
      requires child.object_state.up_vector( time )
    {
      [return_res child.object_state.up_vector( time t )];
    }
    resulting up_vector( stretch s ) 
      requires child.object_state.up_vector( stretch )
    {
      [return_res child.object_state.up_vector( stretch s )];
    }
  }
}
