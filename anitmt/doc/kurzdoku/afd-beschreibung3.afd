/*****************************************************************************/
/**   Specification of the AFD language                                     **/
/*****************************************************************************/
/**									    **/
/** Author: Martin Trautmann, Manuel Moser				    **/
/**									    **/
/** EMail:   martintrautmann@gmx.de					    **/
/**									    **/
/** License: GPL - free and without any warranty - read COPYING             **/
/**									    **/
/** Package: AniTMT							    **/
/**									    **/
/** Date: 20.2.2002							    **/
/**									    **/
/*****************************************************************************/

base_types {
  <newtype> = <oldtype>;
  <newtype> = { <oldtype> <name>, <oldtype> <name>,... };
}


[serial] type <ProviderType> {
  provides <ReturnType>(<ParameterType>);
  provides <ReturnType>(<ParameterType>);
  ...
}

// currently a node may be reopened! FIX?
[abstract] node <TreeNodeName> [extends <TreeNodeName> [, ...]] 
  [provides <ProviderType> [, ...]] 
// ignore multiple occurence of the same provided type?
{
  properties {
    // type scalar may be reopened!
    type scalar {
      <PropertyName>; 
      <PropertyName>; 
      ...
    }
    type vector {
      <PropertyName>;
      <PropertyName>; 
      ...
    }
    type string {
      <PropertyName>;
      <PropertyName>; 
      ...
    }
    scalar <PropertyName>; 
    string <PropertyName>; 
    vector <PropertyName>; 
    ...
  }
  aliases {
// not implemented yet: currently ignored
    <PropertyAliasName> = <PropertyName>;   // <PropertyAliasName> are only for users !!!
    ...
  }
  operands {
    type scalar {
      <OperandName>;  // BlindProperies (Not accessable by user)
      <OperandName>; 
      ...
    }
    type vector {
      <OperandName>;
      <OperandName>; 
      ...
    }
    type string {
      <OperandName>;
      <OperandName>; 
      ...
    }
    scalar <OperandName>; 
    string <OperandName>; 
    vector <OperandName>; 
    ...
  }
   
  common {
    constraints {
      <boolexpression>;
      <boolexpression>;
      ...
    }
    solvers {
      <Solvername> ( <Propertyreference>, <Propertyreference>, ... );
      <Solvername> ( <Propertyreference>, <Propertyreference>, ... );
      <PropertyName> = <expression>;
      <PropertyName> = <expression>;
      ...
    } 
    actions {
      default( <Prioritylevel>, <Propertyreference>, <expression> );
      ...
      push( <Prioritylevel>, <Propertyreference>, <Propertyreference> );
      ...
// allow further actions?
//      <ActionName> ( <Prioritylevel>, <Propertyreference>, <Propertyreference>, ... );
      ...
    }
  }
  first [<ProviderType>]{
    constraints { ... }
    solvers { ... } 
    actions { ... }
  }
  last [<ProviderType>]{
    constraints { ... }
    solvers { ... } 
    actions { ... }
  }
  
  contains {
    [max1] [min1] <ProviderType>;
    [max1] [min1] <ProviderType>;
    ...
  }
   
  provide <ProviderType> {
    resulting <ReturnType>( <ParameterType> <ParameterName> ) 
// optional things are currently not implemented!
      [ requires <Propertyname> | child.<ProviderType>[.<ReturnType>(<ParameterType>)] | this.[<ProviderType>.]<ReturnType>(<ParameterType>) , ... ] 
    {
      <Any C++-Code using 
       <Propertyname>
//!!! rethink about all this references...
// default value and failvar isn't implemented yet
       child.<ProviderType>.<ReturnType>(<ParameterType> <Parameter>)[,<defaultvalue>[,<failboolvar>]] 
       this.[<ProviderType>.]<ReturnType>(<ParameterType> <Parameter>)
       return <C-Variablename>
       return_prop <Propertyname>
       return_res child.<ProviderType>.<ReturnType>(<ParameterType> <Parameter>) 
       return_res this.[<ProviderType>.]<ReturnType>(<ParameterType> <Parameter>)
       //<<< I was thinking about:
       return_fail			// return undefined
       return_if_fail			// return if last command failed
       check_fail			// return true if last command failed
       //<<< 
       ...
       in SQ_Brackets("[]") 
      >
    }
    ...
  }
}

/*
    **examples:**
      scalar x = [start_time] + 3;
      if( x > 5 )
        [return x];
      else
        [return_prop end_time];
*/

/* future example could look like
bool x_failed;
x = [child.scalar_vsa.value(t),0,x_failed];
if( x_failed )
{
  // x is 0!!!
  return false;
}
*/

<Propertyreference>:    <PROPERTYNAME>
                      | <OPERANDNAME>
                      | <Nodereference>.<PROPERTYNAME>
                      | <PROVIDERTYPE>.<RETURNTYPE>(<PARAMETERTYPE>).start_param                    // range properties for result function
                      | <PROVIDERTYPE>.<RETURNTYPE>(<PARAMETERTYPE>).end_param                    
<Nodereference>:        <Localnodeidentifier>
                      | <Nodeidentifier>
                      | <Nodereference>.<Nodeidentifier>                           // recursive
<Localnodeidentifier>:  <PROVIDERTYPE>.prev                           // return type specific sequence
                      | <PROVIDERTYPE>.next                    
                      | child.<CHILDNAME>.first                     
                      | child.<CHILDNAME>.last
                      | child.<CHILDNAME>[n]
<Nodeidentifier>:       prev
                      | next
                      | parent
                      | first_child
                      | last_child
                      | child[n]
