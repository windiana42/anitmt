///////////////////////////////////////////////////////////////////////////////
/*****************************************************************************/
/*                                                                           */
/*                                scalar functions                           */
/*                                                                           */
/* subfunctions for scalar animations                                        */
/*                                                                           */
/* - scalar_subfunction (abstract base type)                                 */
/* - change (container type for scalars)                                     */
/* - constant                                                                */
/* - linear                                                                  */
/* - accelerated                                                             */
/*                                                                           */
/*****************************************************************************/
///////////////////////////////////////////////////////////////////////////////


// ****************************************************************************
// ****************************************************************************
// ** dependence
// ****************************************************************************
// ****************************************************************************


include declaration "base_func.afd";
include declaration "scalar_base.afd";

// ****************************************************************************
// ****************************************************************************
// ** node definitions
// ****************************************************************************
// ****************************************************************************

// +--------------------+
// | scalar_subfunction |
// +--------------------+

// abstract type for scalar subfunctions 
abstract node scalar_subfunction extends scalar_base provides scalar_vsa {
  
  common {
    actions {
      // times, forward and backward
      push( push_time_fw, end_time, scalar_vsa.next.start_time );
      push( push_time_bw, start_time, scalar_vsa.prev.end_time );
      // values, forward and backward
      push( push_state_fw, end_value, scalar_vsa.next.start_value );
      push( push_state_bw, start_value, scalar_vsa.prev.end_value );
      // slopes, forward and backward
      push( push_speed_fw, end_slope, scalar_vsa.next.start_slope );
      push( push_speed_bw, start_slope, scalar_vsa.prev.end_slope );
    }
  }

}



// +--------+
// | change |
// +--------+

// changing values (container for scalar functions)
node change extends scalar_subfunction {
  
  // scalar subfunction provider type 
  contains {
    min1 scalar_vsa ;
  }
  
  common {
    solvers {
      // setting result function parameters
      equal_solver( start_time, scalar_vsa.value(time).start_param );
      equal_solver( end_time  , scalar_vsa.value(time).end_param   );
      equal_solver( start_time, scalar_vsa.slope(time).start_param );
      equal_solver( end_time  , scalar_vsa.slope(time).end_param   );
      equal_solver( start_time, scalar_vsa.acceleration(time).start_param );
      equal_solver( end_time  , scalar_vsa.acceleration(time).end_param   );

      // connection to subfunctions
      equal_solver ( start_time , first_child.start_time  );
      equal_solver ( start_value, first_child.start_value );
      equal_solver ( start_slope, first_child.start_slope );
      equal_solver ( end_time , last_child.end_time  );      
      equal_solver ( end_value, last_child.end_value );      
      equal_solver ( end_slope, last_child.end_slope );      
    }
  }

  // result functions using the scalar subfunctions
  provide scalar_vsa {
    resulting value( time t ) requires child.scalar_vsa.value ( time ) { 
      [[ return child.scalar_vsa.value ( time t ) ]];
    } 
    resulting slope( time t ) requires child.scalar_vsa.slope ( time ) {
      [[ return child.scalar_vsa.slope ( time t ) ]];
    }
    resulting acceleration( time t ) requires child.scalar_vsa.acceleration ( time ) {
      [[ return child.scalar_vsa.acceleration ( time t ) ]];
    }
  }
}

// --- MM: work marker! ---

// +----------+
// | constant |
// +----------+

// constant value
node constant extends scalar_subfunction {
  
  // special properties for constant
  properties{
    type scalar {    
      value;
      slope;
      acceleration;
    }
  }
  
  common {
    solvers {
      // setting result function parameters
      equal_solver( start_time, scalar_vsa.value(time).start_param );
      equal_solver( end_time  , scalar_vsa.value(time).end_param   );
      equal_solver( start_time, scalar_vsa.slope(time).start_param );
      equal_solver( end_time  , scalar_vsa.slope(time).end_param   );
      equal_solver( start_time, scalar_vsa.acceleration(time).start_param );
      equal_solver( end_time  , scalar_vsa.acceleration(time).end_param   );

      // solvers for constant
      difference = 0; 
      slope_difference = 0; slope = 0;
      acceleration = 0;
      equal_solver( value, start_value );
      equal_solver( value, end_value );
    }
    
    actions {
      default( default_duration, duration, 0 );
      default( default_state, start_value, 0 );
    }
  }

  // result functions for constant
  provide scalar_vsa {
    resulting value( time t ) requires value
    {
      [[ return_prop value ]];
    }
    resulting slope( time t ) 
    {
      [[ return 0 ]];
    }
    resulting acceleration( time t ) 
    {
      [[ return 0 ]];
    }
  }
}

// +--------+
// | linear |
// +--------+

// linear change of a value
node linear extends scalar_subfunction provides scalar_vsa {

  // special properties for linear
  properties{
    type scalar {    
      slope;
      acceleration;
    }
  }

  common {
    solvers {
      // setting result function parameters
      equal_solver( start_time, scalar_vsa.value(time).start_param );
      equal_solver( end_time  , scalar_vsa.value(time).end_param   );
      equal_solver( start_time, scalar_vsa.slope(time).start_param );
      equal_solver( end_time  , scalar_vsa.slope(time).end_param   );
      equal_solver( start_time, scalar_vsa.acceleration(time).start_param );
      equal_solver( end_time  , scalar_vsa.acceleration(time).end_param   );

      acceleration = 0;
      product_solver( difference, slope, duration );
      equal_solver( slope, start_slope );
      equal_solver( slope, end_slope   );
    }
    actions {
      default( default_speed, slope, 0 );
      default( default_duration, duration, 0 );
      default( default_state, start_value, 0 );
    }
  }

  // result functions for linear
  provide scalar_vsa {
    resulting value( time t ) requires start_value, start_time, slope
    {
      scalar res = [[ start_value ]] + (t - [[ start_time ]]) * [[ slope ]];
      [[ return res ]];
    }
    resulting slope( time t ) requires slope
    {
      [[ return_prop slope ]];
    }
    resulting acceleration( time t ) 
    {
      [[ return 0 ]];
    }
  }
}


// +-------------+
// | accelerated |
// +-------------+

// accelerated change of values
node accelerated extends scalar_subfunction provides scalar_vsa {

  // special properties for accelerated
  properties{
    scalar acceleration;
  }

  common {
    solvers {
      // setting result function parameters
      equal_solver( start_time, scalar_vsa.value(time).start_param );
      equal_solver( end_time  , scalar_vsa.value(time).end_param   );
      equal_solver( start_time, scalar_vsa.slope(time).start_param );
      equal_solver( end_time  , scalar_vsa.slope(time).end_param   );
      equal_solver( start_time, scalar_vsa.acceleration(time).start_param );
      equal_solver( end_time  , scalar_vsa.acceleration(time).end_param   );

      // acceleration solvers
      // still wrong (simple solver):
      accel_solver(difference, duration, acceleration, start_slope, end_slope);
      // correct (better solver): 
      // accel_solver(difference, duration, acceleration, start_slope, end_slope, slope_difference);
    }
    actions {
      default( default_acceleration,  acceleration, 0 ); 
      // <-- still wrong better is:
      // default(200,  slope_difference, 0 );
      default( default_speed, start_slope, 0 );
      default( default_duration, duration, 0 );
      default( default_state, start_value, 0 );
    }
  }

  // result functions for accelerated
  provide scalar_vsa {
    resulting value(time abs_t) 
    requires start_value, start_time, start_slope, acceleration
    {
      scalar t = abs_t - [[ start_time ]];
      scalar res = [[ start_value ]] + [[ start_slope ]]*t 
                   + 0.5*[[ acceleration ]]*t*t;
      [[ return res ]];
    }
    resulting slope( time abs_t ) 
    requires start_time, start_slope, acceleration
    {
      scalar t = abs_t - [[ start_time ]];
      scalar res = [[ start_slope ]] + [[ acceleration ]] * t;
      [[ return res ]];
    }
    resulting acceleration( time t ) 
    requires acceleration
    {
      [[ return_prop acceleration ]];
    }
  }
}

// ****************************************************************************
// ****************************************************************************
// ** Just for Fun ähhh Test
// ****************************************************************************
// ****************************************************************************

// +----------+
// | separator |
// +----------+

// separator value
node separator extends scalar_subfunction {
  
  // special properties for separator
  properties{
    type scalar {    
      condition;
    }
  }
  
  common {
    solvers {
      // setting result function parameters
      equal_solver( start_time, scalar_vsa.value(time).start_param );
      equal_solver( end_time  , scalar_vsa.value(time).end_param   );
      equal_solver( start_time, scalar_vsa.slope(time).start_param );
      equal_solver( end_time  , scalar_vsa.slope(time).end_param   );
      equal_solver( start_time, scalar_vsa.acceleration(time).start_param );
      equal_solver( end_time  , scalar_vsa.acceleration(time).end_param   );

      // solvers for separator
    }
    
    actions {
      default( default_duration, duration, 0 );
      default( default_state, start_value, 0 );
    }
  }

  common {
    actions {
      // times, forward and backward
      condition_push( push_time_fw, start_time, scalar_vsa.next.start_time,
	condition > 0 );
      condition_push( push_time_bw, end_time, scalar_vsa.prev.end_time,
	condition > 0 );
      // values, forward and backward
      condition_push( push_state_fw, start_value, scalar_vsa.next.start_value,
	condition > 0 );
      condition_push( push_state_bw, end_value, scalar_vsa.prev.end_value,
	condition > 0 );
      // slopes, forward and backward
      condition_push( push_speed_fw, start_slope, scalar_vsa.next.start_slope,
	condition > 0 );
      condition_push( push_speed_bw, end_slope, scalar_vsa.prev.end_slope,
	condition > 0 );
    }
  }

  // result functions for separator
  provide scalar_vsa {
    resulting value( time t ) requires start_value
    {
      [[ return_prop start_value ]];
    }
    resulting slope( time t ) 
    {
      [[ return_prop start_slope ]];
    }
    resulting acceleration( time t ) 
    {
      [[ return 0 ]];
    }
  }
}

