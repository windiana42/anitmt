/*
 * lproto.hpp
 * 
 * Misc stuff for output routines. 
 * 
 * Copyright (c) 2001--2002 by Wolfgang Wieser (wwieser@gmx.de) 
 * 
 * This file may be distributed and/or modified under the terms of the 
 * GNU General Public License version 2 as published by the Free Software 
 * Foundation. 
 * 
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 * 
 */


#ifndef _Inc_IO_Lib_LProto_H_
#define _Inc_IO_Lib_LProto_H_ 1

// Include the config generated by configure: 
#include <config.h>

// Okay, standard include stuff: 
#include <stdio.h>
#if HAVE_SYS_TYPES_H
# include <sys/types.h>
#endif
#if HAVE_SYS_STAT_H
# include <sys/stat.h>
#endif
#if STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# if HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif
#if HAVE_STRING_H
# if !STDC_HEADERS && HAVE_MEMORY_H
#  include <memory.h>
# endif
# include <string.h>
#endif
#if HAVE_INTTYPES_H
# include <inttypes.h>
#else
# if HAVE_STDINT_H
#  include <stdint.h>
# endif
#endif
#if HAVE_UNISTD_H
# include <unistd.h>
#endif


// Now some stuff: 
#if !defined(HAVE_SSIZE_T) || (defined(HAVE_SSIZE_T) && !HAVE_SSIZE_T)
typedef signed int ssize_t;
#endif

#if HAVE_GETTIMEOFDAY && !defined(CALC_ELAPSED_TIME)
#  define CALC_ELAPSED_TIME 1
#endif



#if CALC_ELAPSED_TIME

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

extern "C"
{ long msec_elapsed(const struct timeval *old,const struct timeval *current); }

#include <string>
extern std::string Throughput_Str(size_t nbytes,double elapsed);

// timeval and time_t replacement 
class HTime
{
	public:
		enum TimeSpec
		{  usec=0,msec,seconds,minutes,hours,days,_tslast  };
	private:
		timeval tv;
		static const long long conv_fact[];
		static const double conv_factD[];
		
		void _SetVal(long val,TimeSpec sp,timeval *tv);
		void _Delta(const HTime *endtime,long long *delta) const;
	public:
		HTime() { }
		~HTime() { }
		
		// Copy: 
		HTime(const HTime &h) : tv(h.tv) { }
		HTime &operator=(const HTime &h)  {  tv=h.tv;  return(*this);  }
		
		// Store/set value (SetCurr() for current time; others never needed): 
		HTime(long val,TimeSpec sp=msec)  // BE SURE val>=0. 
			{  _SetVal(val,sp,&tv);  }
		int SetCurr()
			{  return(gettimeofday(&tv,NULL));  }
		HTime &Set(long val,TimeSpec sp=msec)  // BE SURE val>=0. 
			{  _SetVal(val,sp,&tv);  return(*this);  }
		
		// Arithmetics: (val may be <0) 
		HTime &Add(long val,TimeSpec sp=msec);
		HTime &Sub(long val,TimeSpec sp=msec);
		
		// To compare time values: 
		int operator==(const HTime &h) const
			{  return(tv.tv_sec==h.tv.tv_sec && tv.tv_usec==h.tv.tv_usec);  }
		int operator!=(const HTime &h) const
			{  return(tv.tv_sec!=h.tv.tv_sec || tv.tv_usec!=h.tv.tv_usec);  }
		int operator>(const HTime &h) const
			{  return(tv.tv_sec>h.tv.tv_sec || 
			         (tv.tv_sec==h.tv.tv_sec && tv.tv_usec>h.tv.tv_usec));  }
		int operator<(const HTime &h) const
			{  return(tv.tv_sec<h.tv.tv_sec || 
			         (tv.tv_sec==h.tv.tv_sec && tv.tv_usec<h.tv.tv_usec));  }
		int operator>=(const HTime &h) const
			{  return(tv.tv_sec>h.tv.tv_sec || 
			         (tv.tv_sec==h.tv.tv_sec && tv.tv_usec>=h.tv.tv_usec));  }
		int operator<=(const HTime &h) const
			{  return(tv.tv_sec<h.tv.tv_sec || 
			         (tv.tv_sec==h.tv.tv_sec && tv.tv_usec<=h.tv.tv_usec));  }
		
		// Time differences: 
		// starttime: *this; endtime: NULL=current 
		// BEWARE OF OVERFLOWS. 
		long   Elapsed (TimeSpec sp,const HTime *endtime=NULL) const;
		double ElapsedD(TimeSpec sp,const HTime *endtime=NULL) const;
		// Faster: 
		long MsecElapsed() const
			{  return(msec_elapsed(&tv,NULL));  }
		long MsecElapsed(const HTime *endtime) const  // endtime is NON-NULL
			{  return(msec_elapsed(&tv,&endtime->tv));  }
};


inline long HTime::Elapsed(TimeSpec sp,const HTime *endtime) const
{
	if(sp>=_tslast)  return(-1L);
	long long tmp;  _Delta(endtime,&tmp);
	return(long((tmp)/conv_fact[sp]));
}

inline double HTime::ElapsedD(TimeSpec sp,const HTime *endtime) const
{
	if(sp>=_tslast)  return(-1L);
	long long tmp;  _Delta(endtime,&tmp);
	return(double(tmp)/conv_factD[sp]);
}

#else  /* CALC_ELAPSED_TIME */

class HTime
{
	public:
		HTime() { }
		~HTime() { }
};

#endif  /* CALC_ELAPSED_TIME */

#endif  /* _Inc_IO_Lib_LProto_H_ */
